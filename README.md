### Мета роботи:
Опрацювання алгоритмів з двійковим деревами пошуку та AVL-деревами
- Написання алгоритму (функції), який знаходить найбільше значення у двійковому дереві пошуку або в AVL-дереві. 
- Написання алгоритму (функції), який знаходить найменше значення у двійковому дереві пошуку або в AVL-дереві.
- Написання алгоритму (функції), який знаходить суму всіх значень у двійковому дереві пошуку або в AVL-дереві.

### Виконання

Цей код реалізує самобалансоване AVL‑дерево на Python з можливістю графічного відображення структури дерева через matplotlib і networkx.
### 1. Клас Node
Кожен вузол дерева містить:
- key — значення вузла.
- left і right — посилання на лівого та правого нащадків.
- height — висоту вузла (потрібна для балансування).
- Метод `__str__` рекурсивно створює текстове представлення дерева.

### 2. Допоміжні функції:

- `get_height(node)` — повертає висоту вузла.
- `get_balance(node)` — рахує баланс‑фактор: balance = height(left) − height(right)
- `find_min(root) / find_max(root)` — шукають найменше і найбільше значення в дереві.
- `sum_values(root)` — рекурсивно сумує всі ключі вузлів.

### 3. Операції поворотів
Для підтримання балансу AVL‑дерева використовуються ротації:
- left_rotate(z) - Піднімає праве піддерево вузла z вгору, коли дерево "завалене вправо".
- right_rotate(z) - Піднімає ліве піддерево вгору, коли дерево "завалене вліво".

### 4. Функція insert(root, key):

Це основна функція вставки елемента в AVL‑дерево.
Послідовність дій:
1. Якщо root — None, створюється новий об’єкт Node.
2. Інакше виконується звичайна вставка, як у звичайному бінарному дереві пошуку:
   - Якщо key < root.key → ліве піддерево.
   - Інакше → праве піддерево.
3. Оновлюється висота вузла.
4. Обчислюється баланс‑фактор.
5. Якщо баланс зруйновано, виконується одна з 4 можливих ротацій:
   - Left‑Left (LL) → right_rotate(root)
   - Right‑Right (RR) → left_rotate(root)
   - Left‑Right (LR) → спочатку лівий, потім правий поворот
   - Right‑Left (RL) → спочатку правий, потім лівий поворот
6. Повертається новий корінь збалансованого піддерева.

### 5. Основна програма `(if __name__ == "__main__":)`:
1. Створюється порожнє дерево (root = None).
2. Вставляються ключі від 1 до 15 у зростаючому порядку.
   - Завдяки балансуванню AVL‑алгоритм створює повністю збалансоване дерево, а не "список".
3. Друкується дерево у консолі.
4. Виводиться:
   - максимальне значення;
   - мінімальне;
   - сума.
5. Викликається функція draw_tree(root) для відображення дерева графічно.

### Висновки:
1. Код реалізує структуру AVL‑дерева, що автоматично збалансовує себе після кожної вставки.
2. Алгоритм показує, як підтримувати рівновагу дерева для ефективного пошуку, вставки й видалення.
3. Візуалізація за допомогою networkx дає зручний графічний огляд структури.
